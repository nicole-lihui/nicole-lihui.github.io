# 操作系统体系结构和内存层次结构

## 操作系统体系结构
1. CPU
2. 内存
3. IO
   
### 内存层次结构
1. 寄存器、运算器、控制器、cash等【容量小、速率快】
2. 主存：【容量大、速率比CPU慢】掉电数据丢失
3. 硬盘：【容量比主存大、速率比主存慢】保存需要永久保存的数据

### 操作系统管理物理内存
#### 目标
1. 抽象：逻辑地址空间【程序看到的】
2. 保护【隔离】：独立地址空间
3. 共享：访问相同的内存
4. 虚拟化：更多的地址空间（需要的数据放内存、暂时不需要的数据可以放在硬盘上、后期再加载）

#### OS管理内存的不同方法
1. 程序重定位
2. 分段
3. 分页
4. 虚拟内存
5. 按需分页虚拟内存

---
### 地址空间 && 地址生成
#### 地址定义
1. 物理地址空间：硬件支持的地址空间
2. 逻辑地址空间：一个运行程序所拥有的内存范围
> OS管理逻辑地址和物理地址的映射关系

#### 地址生成
1. 逻辑地址空间生成
   * 编译---【汇编语言】变量名、函数位置是地址（c程序）
   * 汇编
   * 链接
   * 程序重定位（相对从零开始的逻辑地址）【在硬盘的执行程序】
   * loader将执行程序加载到内存中运行、根据放在内存中逻辑地址进行分配，地址会有一个偏移量，程序根据偏移量可以正确执行
  
  > 这时逻辑地址依旧是程序所见的地址，不是真正的物理地址
2. 物理地址的生成
  > CPU中的MMU保存映射关系()

    1. CPU发请求ALU，传递参数-逻辑地址给ALU
    2. MMU查找逻辑地址映射的物理地址，有就继续，没有就去内存Map中找
    3. （如果找到了）CPU控制器发出请求：需要该物理地址的内容
    4. CPU就去内存中loader该指令
> 该过程OS建立映射关系、确保内存中程序相互不干扰（限制和约束）

#### 地址安全检查
> 限制和约束
1. OS设置每个程序的地址空间的基址和界限（起始地址和长度）
   1. 基址寄存器 【+】
   2. 限界寄存器 【<=】

---
## 内存分配

### 连续内存分配
#### 内存碎片问题
1. 空闲内存不能被利用——碎片
   1. 外碎片：分配单元之间无法使用的内存
   2. 内碎片：在分配单元中无法使用的内存

#### 简单的内存管理方法
1. 当一个程序运行在内存中的时，需要分配一个连续的区间给程序
2. 给运行程序的访问的数据需要分配一个连续分配的内存区间

#### 分配策略
1. 首次适配
  * 优点:
    1. 简单
    2. 容易产生更大的空闲快
  * 缺点：
    1. 容易产生外碎片
    2. 不确定性
2. 最优适配
> 需要实现排序空闲块排序

   * 优点：
    1. 当大部分分配是小尺寸时非常有效，避免对大尺寸空间的拆分、外部碎片产生最小化
    2. 比较简单
   * 缺点：
    1. 把外碎片拆分很小、不利于后续的管理（易产生很多没有的细小碎片）
    2. 重分配慢
   
3. 最差适配
   * 优点：
    1. 分配中等尺寸碎片效果最好，拆分大碎片
   * 缺点：
    1. 重分配慢
    2. 易于破碎大的空闲块以至于大分区无法被分配

#### 碎片整理
1. 压缩式碎片整理
   将程序移动，将碎片合并
   * 重置程序以合并孔洞
   * 要求所以程序是动态可重置的

2. 交换式碎片整理
   * 将暂时等待的程序临时移动到硬盘中

### 非连续内存分配
1. 优点
   1. 一个程序的物理地址空间是非连续的
   2. 更好的内存利用和管理
   3. 允许共享代码和数据（共享库等...）
   4. 支持动态加载和动态链接

2. 缺点
   1. 管理开销大

#### 如何建立虚拟地址和物理地址之间的转换
1. 软件方案：开销相当大
2. 硬件方案

#### 硬件方案
1. 分段
   * 程序如何分段
   * 分段如何寻址
2. 分页
3. 分段和分页的区别
   * 段大小不固定、页大小固定
