# 数据库相关


## 索引
1. 索引的底层实现原理和优化
* 索引的原理：建立索引表，存放索引字段值以及对应记录的物理地址，从而在搜索的时候根据字段值搜索索引表的到物理地址直接访问记录
* 索引类型：B树索引，位图索引，函数索引等
* 实现数据结构：B+树，


1. 简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）
* 主键索引：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字PRIMARY KEY 来创建。
* 普通索引：(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。
* 主键索引和普通索引的区别: 主键索引可以保证数据记录的唯一性，普通索引允许被索引的数据列包含重复的值。
* 索引优点：
  * 索引可以极大的提高数据的查询速度
  * 使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间
  * 加速表和表之间的连接
  * 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能
* 索引缺点：
  * 创建索引和维护索引需要耗费时间
  * 索引需要占用物理空间
  * 当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度

3. 什么情况下设置了索引但无法使用 
* 以“%”开头的LIKE语句，模糊匹配
* OR语句前后没有同时使用索引
* 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）

4. 建立索引的原则
* 建议建立索引：
  * 频繁使用的、用以缩小查询范围的字段
  * 频繁使用的、需要排序的字段
* 不宜建立索引：
  * 查询中很少涉及的列或者重复值比较多的列
  * 一些特殊的数据类型，比如文本字段（text）等

5. 数据库索引为什么用B+树实现
6. 索引类型
* 普通索引
  >是最基本的索引，它没有任何限制。
* 唯一索引
  >与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
* 组合索引
  >指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。
* 主键索引
  >是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引
* 全文索引
  >主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。


## 事务
1. 四大特性
* 原子性
  >事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。
* 一致性
  >事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。
  >如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。
* 隔离性
  >一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。
* 持续性
  >也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。

1. 四种隔离级别
* Read Uncommitted（读取未提交内容）
> 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）

* Read Committed（读取提交内容）
  >这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。
* Repeatable Read（可重读）
  >这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。
  简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。
* Serializable（可串行化）
  >这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

## 数据引擎

## 优化
1. 分库分表
[面试官:"谈谈分库分表吧？"](https://zhuanlan.zhihu.com/p/54921615)

2. 查询优化
[MySQL慢查询优化、索引优化、以及表等优化总结](https://zhuanlan.zhihu.com/p/49592137)
* 索引的优化
  * 只要列中含有NULL值，就最好不要在此例设置索引，复合索引如果有NULL值，此列在使用时也不会使用索引
  * 尽量使用短索引，如果可以，应该制定一个前缀长度
  * 对于经常在where子句使用的列，最好设置索引，这样会加快查找速度
  * 对于有多个列where或者order by子句的，应该建立复合索引
  * 对于like语句，以%或者‘-’开头的不会使用索引，以%结尾会使用索引
  * 尽量不要在列上进行运算（函数操作和表达式操作）
  * 尽量不要使用not in和<>操作
* sql语句的优化
  * 捕获低效sql
  * 慢查询优化的基本步骤：
    * 确认查询速度是否很慢
    * where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高
    * explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）
    * order by limit 形式的sql语句让排序的表优先查
    * 了解业务方使用场景
    * 加索引时参照建索引的几大原则
    * 观察结果，不符合预期继续从1开始分析
  * 优化原则
    * 查询时，能不要*就不用*，尽量写全字段名
    * 大部分情况连接效率远大于子查询
    * 多使用explain和profile分析查询语句
    * 查看慢查询日志，找出执行时间长的sql语句优化
    * 多表连接时，尽量小表驱动大表，即小表 join 大表
    * 在千万级分页时使用limit
    * 对于经常使用的查询，可以开启缓存
* 表的优化
  * 表的字段尽可能用NOT NULL
  * 字段长度固定的表查询会更快
  * 把数据库的大表按时间或一些标志分成小表
  * 拆分表
    * 水平切分:将记录散列到不同的表中，各表的结构完全相同，每次从分表中查询, 提高效率
    * 垂直切分:将表中大字段单独拆分到另外一张表, 形成一对一的关系
    * 

